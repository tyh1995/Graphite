Graphite
====
Graphite执行两个相当简单的任务：存储随时间变化的数字并绘制它们。多年以来有许许多多的软件能做到同样的事情，Graphite能脱颖而出是因为它以易使用并且可扩展的网络服务的形式提供这个功能。向Graphite输送数据的协议简单到你能在几分钟内学会该怎么做（并不是因为你会想这么做，而是因为这是检测简单性的有效方法）。绘制图形和检索数据点容易的像获取一个网址。这使得Graphite和其它软件的结合非常自然并且让用户能够在Graphite的基础上建造出更强大的软件。Graphite最常见的用途是建造基于网络的用于监视和分析的仪表盘。Graphite诞生在高流量的电子商务环境下，它的设计也体现这一点。可扩展性和实时数据访问是主要目标。<br>
让Graphite得已实现这些目标的部件包括一个专门的数据库及其存储结构、一个优化I/O操作的缓存机制和一个简单但有效的Graphite服务器聚集的方法。比起简单的描述Graphite现在是如何工作的，我更愿意解释Graphite最初是如何实现的（相当天真）、我遇到了什么问题以及我是如何解决这些问题的。<br>
7.1. 数据库：存储时间序列数据
----
Graphite完全用Python写成，它由三个主要部分构成：一个名为`whisper`的数据库，一个名为`carbon`的后端守护进程，以及一个显示图形并提供基本UI的前端web应用。虽然`whisper`是专门为Graphite写的，但是它也可以被单独使用。从设计上来说，它和RRDtool使用的RRD数据库十分相似，只存储时间序列数字数据。我们通常将数据库视为服务器进程，客户端应用通过sockets与之交互。但是`whisper`是一个被应用用来操作和获取存储在特殊格式文件中数据的数据库，这一点与RRDtool十分相似。最基本的`whisper`操作是`create`用于创建一个新的`whisper`文件，`update`用于将新的数据点写到文件中，以及`fetch`用于获取数据点。<br>
　　　　　　　　　　　　![](https://github.com/tyh1995/Graphite/blob/master/graphs/1.png)<br>
　　　　　　　　　　　　　　　　　　　图7.1：`whisper`文件的基本结构<br>
像图7.1中展示的那样，`whisper`文件由一个包含各种原数据的header节以及跟在其后的一个或多个archive节构成。每个archive都是一系列的连续数据点，这些数据点的格式为`(timestamp, value)`对。每当一个`update`或`fetch`操作被执行时，`whisper`根据timestamp以及archive配置来确定数据在文件中被写入或读取的位置。<br>
7.2. 后端：简单的存储服务
----
Graphite的后端是一个名为`carbon-cache`的守护进程，简称`carbon`。它基于一个名为Twisted的高度可扩展的Python事件驱动I/O框架。Twisted使得`carbon`能够低开销的与大量客户端交互并处理大量数据。图7.2展示了`carbon`，`whisper`以及web应用之间的数据流：客户端应用收集数据并将其发送给Graphite后端`carbon`，然后`carbon`通过`whisper`存储数据。这些数据则被web应用用来生成图形。<br>
　　　　　　　　　　　　![](https://github.com/tyh1995/Graphite/blob/master/graphs/2.png)<br>
　　　　　　　　　　　　　　　　　　　图7.2：数据流<br>
`carbon`主要的功能是存储客户端提供的度量的数据点。在Graphite术语中，一个度量是任何随时间变化的可测量的数量（比如一个服务器的CPU使用率以及产品的销量）。一个数据点就是一个`(timestamp, value)`对，其与某个时间点上对一个特定度量的测量值相一致。度量由他们的名字唯一确定，而它们的名字和其数据点一样由客户端应用提供。比较常见的客户端应用类型是监控代理，其功能是收集系统或应用度量并向`carbon`收集到的数据用于简易存储和可视化。Graphite中的度量有简单分层的名字，这和文件系统路径名十分相似，唯一的区别是用于分层的是点而不是斜杠或反斜杠。`carbon`接受任何合法的名字并且为每个度量创建一个`whisper`文件用于存储其数据点。`whisper`文件存储在`carbon`的数据目录下，其路径名由度量的名字映射而来，例如`servers.www01.cpuUsage`映射到`…/servers/www01/cpuUsage.wsp`。<br>
每当一个客户端应用想要发送数据点给Graphite时，它都需要与`carbon`建立一个TCP连接，这个连接通常使用2003端口。所有的数据发送都由客户端完成；`carbon`在连接过程中不发送任何东西。客户端以简单的纯文本格式发送数据点，而这个连接可能会被保持以备后续使用。这个格式是每个数据点一行，每行包含度量名、值以及一个Unix时间戳，它们之间以空白分割。比如客户端也许会发送如下数据：<br>
>servers.www01.cpuUsage 42 1286269200<br>
products.snake-oil.salesPerMinute 123 1286269200<br>
[one minute passes]<br>
servers.www01.cpuUsageUser 44 1286269260<br>
products.snake-oil.salesPerMinute 119 1286269260<br>

从顶层来看，`carbon`所做的所有事情就是监听这个格式的数据并通过`whisper`将其尽可能快的存储到磁盘上。稍后我们将会讨论一些在典型磁盘下用于保证可扩展性并且获取最佳表现的小技巧的细节。<br>
7.3. 前端：请求式图形
----
Graphite的web应用允许用户通过一个简单的基于URL的API来请求定制图形。绘图参数通过一个HTTP GET请求的查询字符串确定，一个PNG图形将会被返回给用户。例如如下URL:<br>
>http://graphite.example.com/render?target=servers.www01.cpuUsage&width=500&height=300&from=-24h

为度量`servers.www01.cpuUsage`及其过去24小时的数据请求了一个500×300的图形。事实上，只有target参数是必须的；其他参数都是可选的，如果省略的话将会使用默认值。<br>
Graphite支持很多显示选项以及数据操作函数，调用这些函数只需要通过一个简单的功能语法。比如我们可以按照以下格式为前例中的度量绘制一个有10个点的移动平均图:<br>
>target=movingAverage(servers.www01.cpuUsage,10)

考虑到复杂的表达式和计算，函数可以嵌套。<br>
下面是另一个例子，它给出了当天的销量累计，其度量为每分钟的销量:<br>
>target=integral(sumSeries(products.*.salesPerMinute))&amp;from=midnight

`sumSeries`函数计算出匹配`products.*.salesPerMinute`的度量之和的时间序列。随后`integral`计算出累计和而不是每分钟的数量。由此不难想象应该如何构建一个网站UI来查看和操作图形。像图7.3中展示的那样，Graphite有它自己的Composer UI，这个UI能随着使用者点击各个选项通过Javascript来修改图形的URL参数。<br>
　　　　　　　　　　　　![](https://github.com/tyh1995/Graphite/blob/master/graphs/3.png)<br>
　　　　　　　　　　　　　　　　　　　图7.3：Graphite的Composer界面
7.4. 仪表盘
----
从一开始Graphite就作为创建基于网站的仪表盘的工具被使用。URL API使得这成为一个非常自然的使用方法。创建一个仪表盘就和创建一个满是如下标签的HTML页面一样简单：<br>
>\<img src="../http://graphite.example.com/render?parameters-for-my-awesome-graph">

但是，不是每个人都喜欢手动处理URL，因此Graphite的Composer UI提供了一个点击式的方法来创建一个图形，通过这个方法用户只需要复制粘贴URL就可以达到目的。当Graphite和另外一个允许快婿创建网站页面的工具（如wiki）结合使用时，创建仪表盘将会简单到非技术用户也能轻松搞定。<br>
7.5. 一个明显的瓶颈
----
我的用户一开始创建仪表盘，Graphite很快就遇到了性能上的问题。我研究了网站服务器日志来查看是什么请求让它陷入了泥沼。结果表明问题出在绘图请求的数目上。由于一直在渲染图形，web应用遇到了CPU瓶颈。我发现Graphite收到了大量相同的请求，而这是由仪表盘造成的。<br>
想象一下已有一个包含10张图的仪表盘，它每分钟刷新一次。每当一个用户在浏览器中打开这个仪表盘，Graphite每分钟就需要多处理10张图。这个代价很快就变得十分的高昂。<br>
一个简单的解决方案是每个图形只绘制一次，而每当用户发出请求时就返回给他们这个图形的复制品。Django网站框架（Graphite基于其建造）提供了一个极佳的快速缓存机制，它可以使用多种后端比如分布式内存对象缓存系统。分布式内存对象缓存系统本质上就是一个作为网络服务提供的哈希表。客户端应用可以像操作普通的哈希表一样获取和设置键值对。使用分布式内存对象缓存系统最主要的好处是一个高代价请求（如渲染一个图形）的结果可以被快速存储并且在处理接下来的请求的时候被取出。为了避免一直返回同一张图，该系统可以被配置为每隔一段时间清空缓存的图形。即使这个间隔只有几秒，其为Graphite减轻的负担也是巨大的，因为重复的请求太频繁了。<br>
另一个造成大量渲染请求的情况是用户在Composer UI中改变显示选项和应用函数。用户每次改变某些东西，Graphite都必须重新绘制图形。每个请求都包含了相同的数据，因此将基本数据存储到分布式内存对象缓存系统中也是十分重要的。这使得UI能够保持对用户的响应，因为获取数据的步骤被跳过了。<br>
7.6. 优化I/O
----
想象一下你有60,000个度量需要发送到你的Graphite服务器上，并且每个度量每分钟都有一个数据点。要知道每个度量在文件系统中都有自己的`whisper`文件。这意味着`carbon`每分钟需要对60,000个不同的文件进行一次写操作。只要`carbon`能够每1ms完成一次写操作，这些数据就能够处理完。这确实不难达到，但假如你每分钟有600,000个度量需要更新，或者你的度量每秒钟更新一次，或者你仅仅不能提供足够快的存储，不管是哪种情况，假定数据到来的速度超过了你的存储能够提供的写操作的速度，这个问题应该如何解决？<br>
现在大多数的硬盘都有缓慢的寻找时间，这个缓慢的寻找时间是指和写入一系列连续的数据相比，在两个不同位置进行I/O操作的延时。这就意味着我们进行越多的连续写操作，效率就越高。但是如果我们需要在成千上万的文件中经常进行写操作，并且每次写操作数据量都十分小（一个`whisper`数据点仅有12字节），那么我们的硬盘就肯定会花大量的时间在寻找上。<br>
在写操作速率有一个相对较低顶点的前提下，唯一让数据点流通量超过这个速率的办法就是在单个写操作内写多个数据点。由于`whisper`将连续的数据点连续的存放在硬盘上，所以这是可行的。因此我为`whisper`增加了一个名为`update_many`的函数，其功能是获取一个度量的一系列数据点然后将它们压缩到一个写操作内。尽管这使得每次写操作数据量变大，但是写十个数据点（120字节）和写一个数据点（12字节）在时间上的区别是可以忽略的。在不明显影响时间的前提下，这个函数会尽可能多的获取数据点。<br>
随后我在`carbon`中实现了一个缓冲机制。每个到来的数据点都被映射到一个基于其度量名的队列中并添加到队尾。另一个线程不停的遍历所有的队列，取出所有数据点并将它们通过`update_many`写到对应的`whisper`文件中。现在我们回到之前的例子上，假如我们有600,000个每分钟更新一次的度量，我们的存储设备仅能支持每1ms一次写操作，那么每个队列就会平均保有10个数据点。这个策略唯一消耗的资源就是内存，而这个是相对较充裕的，因为每个数据点都只有十几个字节。<br>
这个策略动态的缓冲尽可能多的数据点以维持数据点到来的速率，保证其不超过存储设备能提供的I/O操作速率。这个方法一个明显的优点是它增加了一定的弹性以解决临时的I/O速率降低问题。如果系统需要进行其它Graphite之外的I/O工作，那么写操作的速率很有可能就会降低，这个时候的`carbon`队列就会增长。队列越大，写的越多。因为所有的数据点流通量等于写操作速率乘以每次写操作的平均大小，所以只要还有足够的内存用于存放队列，`carbon`可以继续运行。`carbon`的队列机制如图7.4所示。<br>
　　　　　　　　　　　　![](https://github.com/tyh1995/Graphite/blob/master/graphs/4.png)<br>
　　　　　　　　　　　　　　　　　　　图7.4：`carbon`的队列机制
