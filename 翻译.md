Graphite
====
Graphite执行两个相当简单的任务：存储随时间变化的数字并绘制它们。多年以来有许许多多的软件能做到同样的事情，Graphite能脱颖而出是因为它以易使用并且可扩展的网络服务的形式提供这个功能。向Graphite输送数据的协议简单到你能在几分钟内学会该怎么做（并不是因为你会想这么做，而是因为这是检测简单性的有效方法）。绘制图形和检索数据点容易的像获取一个网址。这使得Graphite和其它软件的结合非常自然并且让用户能够在Graphite的基础上建造出更强大的软件。Graphite最常见的用途是建造基于网络的用于监视和分析的仪表盘。Graphite诞生在高流量的电子商务环境下，它的设计也体现这一点。可扩展性和实时数据访问是主要目标。<br>
让Graphite得已实现这些目标的部件包括一个专门的数据库及其存储结构、一个优化I/O操作的缓存机制和一个简单但有效的Graphite服务器聚集的方法。比起简单的描述Graphite现在是如何工作的，我更愿意解释Graphite最初是如何实现的（相当天真）、我遇到了什么问题以及我是如何解决这些问题的。<br>
7.1. 数据库：存储时间序列数据
----
Graphite完全用Python写成，它由三个主要部分构成：一个名为`whisper`的数据库，一个名为`carbon`的后端守护进程，以及一个显示图形并提供基本UI的前端web应用。虽然`whisper`是专门为Graphite写的，但是它也可以被单独使用。从设计上来说，它和RRDtool使用的RRD数据库十分相似，只存储时间序列数字数据。我们通常将数据库视为服务器进程，客户端应用通过sockets与之交互。但是`whisper`是一个被应用用来操作和获取存储在特殊格式文件中数据的数据库，这一点与RRDtool十分相似。最基本的`whisper`操作是`create`用于创建一个新的`whisper`文件，`update`用于将新的数据点写到文件中，以及`fetch`用于获取数据点。<br>
　　　　　　　　　　　　![](https://github.com/tyh1995/Graphite/blob/master/graphs/1.png)<br>
　　　　　　　　　　　　　　　　　　　图7.1：`whisper`文件的基本结构<br>
像图7.1中展示的那样，`whisper`文件由一个包含各种原数据的header节以及跟在其后的一个或多个archive节构成。每个archive都是一系列的连续数据点，这些数据点的格式为`(timestamp, value)`对。每当一个`update`或`fetch`操作被执行时，`whisper`根据timestamp以及archive配置来确定数据在文件中被写入或读取的位置。<br>
7.2. 后端：简单的存储服务
----
Graphite的后端是一个名为`carbon-cache`的守护进程，简称`carbon`。它基于一个名为Twisted的高度可扩展的Python事件驱动I/O框架。Twisted使得`carbon`能够低开销的与大量客户端交互并处理大量数据。图7.2展示了`carbon`，`whisper`以及web应用之间的数据流：客户端应用收集数据并将其发送给Graphite后端`carbon`，然后`carbon`通过`whisper`存储数据。这些数据则被web应用用来生成图形。<br>
　　　　　　　　　　　　![](https://github.com/tyh1995/Graphite/blob/master/graphs/2.png)<br>
　　　　　　　　　　　　　　　　　　　图7.2：数据流<br>
`carbon`主要的功能是存储客户端提供的度量的数据点。在Graphite术语中，一个度量是任何随时间变化的可测量的数量（比如一个服务器的CPU使用率以及产品的销量）。一个数据点就是一个`(timestamp, value)`对，其与某个时间点上对一个特定度量的测量值相一致。度量由他们的名字唯一确定，而它们的名字和其数据点一样由客户端应用提供。比较常见的客户端应用类型是监控代理，其功能是收集系统或应用度量并向`carbon`收集到的数据用于简易存储和可视化。Graphite中的度量有简单分层的名字，这和文件系统路径名十分相似，唯一的区别是用于分层的是点而不是斜杠或反斜杠。`carbon`接受任何合法的名字并且为每个度量创建一个`whisper`文件用于存储其数据点。`whisper`文件存储在`carbon`的数据目录下，其路径名由度量的名字映射而来，例如`servers.www01.cpuUsage`映射到`…/servers/www01/cpuUsage.wsp`。<br>
每当一个客户端应用想要发送数据点给Graphite时，它都需要与`carbon`建立一个TCP连接，这个连接通常使用2003端口。所有的数据发送都由客户端完成；`carbon`在连接过程中不发送任何东西。客户端以简单的纯文本格式发送数据点，而这个连接可能会被保持以备后续使用。这个格式是每个数据点一行，每行包含度量名、值以及一个Unix时间戳，它们之间以空白分割。比如客户端也许会发送如下数据：<br>
>servers.www01.cpuUsage 42 1286269200<br>
products.snake-oil.salesPerMinute 123 1286269200<br>
[one minute passes]<br>
servers.www01.cpuUsageUser 44 1286269260<br>
products.snake-oil.salesPerMinute 119 1286269260<br>

从顶层来看，`carbon`所做的所有事情就是监听这个格式的数据并通过`whisper`将其尽可能快的存储到磁盘上。稍后我们将会讨论一些在典型磁盘下用于保证可扩展性并且获取最佳表现的小技巧的细节。<br>
